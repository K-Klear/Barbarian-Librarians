local STATE = require("mod.state")
local SET = require("mod.settings")
local FIGHTER = require("mod.fighters")
local STR = require("mod.string")
local node

local other_player = {2, 1}

local function play_music()
	sound.play("/sound#music", nil, play_music)
end

local function start_round(self)
	STATE.frame, STATE.victor = 0
	if STATE.score[1] > 1 or STATE.score[2] > 1 then
		STATE.score = {0, 0}
		msg.post("bootstrap:/go", hash("game_end"))
	else
		for x = 1, 2 do
			for key, val in pairs(self.player_collections[x]) do
				msg.post(val, hash("delete_self"))
			end
		end

		STATE.health = {100, 100}
		
		self.player_collections, self.player_go = {}, {}
		local facing = {-1, 1}
		for x = 1, 2 do
			gui.set_enabled(node[x].win_1, STATE.score[x] > 0)
			gui.set_enabled(node[x].win_2, STATE.score[x] > 1)
			local props = {[hash("/body")] = {fighter = STATE.fighter[x], controls = x, facing = facing[x]}}
			self.player_collections[x] = collectionfactory.create("#"..FIGHTER[STATE.fighter[x]].atlas, vmath.vector3(SET.starting_x[x], SET.base_y, 0), nil, props)
			self.player_go[x] = self.player_collections[x][hash("/body")]
			gui.set_text(node[x].name_label, FIGHTER[STATE.fighter[x]].name)
			gui.set_scale(node[x].hurt_bar, vmath.vector3(0 / 100, 1, 1))
			gui.animate(node[x].health_bar, "scale.x", 1, gui.EASING_INOUTCUBIC, SET.hurt_bar_speed, 0, function() gui.set_scale(node[x].hurt_bar, vmath.vector3(1, 1, 1)) end)
		end

		msg.post(self.player_go[1], hash("setup_gos"), {enemy = self.player_go[2]})
		msg.post(self.player_go[2], hash("setup_gos"), {enemy = self.player_go[1]})

		if STATE.fighter[1] == STATE.fighter[2] then
			sprite.set_constant(msg.url(nil, self.player_go[2], "sprite"), "tint", SET.mirror_tint)
		end

		gui.set_enabled(node.fight, false)
		gui.set_enabled(node.winner, false)
		gui.set_enabled(node.round, true)
		gui.set_text(node.fight, STR[hash("main_fight")][SET.lang])
		local round = (STATE.score[1] + STATE.score[2] + 1)
		gui.set_text(node.round, STR[hash("main_round")][SET.lang](round))

		timer.delay(0.5, false, function()
			sound.play("/sound#round_"..round, nil, function()
				gui.set_enabled(node.round, false)
				gui.set_enabled(node.fight, true)
				msg.post(self.player_go[1], hash("start"))
				msg.post(self.player_go[2], hash("start"))
				sound.play("sound#fight", nil, function()
					gui.set_enabled(node.fight, false)
				end)
			end)
		end)
	end
end

function init(self)
	local background_list = {"corridor", "court_1", "smoke_break", "hall"}
	sprite.play_flipbook("/background#sprite", (background_list[math.random(#background_list)]))
	self.player_collections = {{}, {}}
	msg.post(".", "acquire_input_focus")
	node = {
		{
			health_bar = gui.get_node("health_p1"),
			name_label = gui.get_node("name_p1"),
			hurt_bar = gui.get_node("hurt_p1"),
			win_1 = gui.get_node("p1_win_1"),
			win_2 = gui.get_node("p1_win_2")
		},
		{
			health_bar = gui.get_node("health_p2"),
			name_label = gui.get_node("name_p2"),
			hurt_bar = gui.get_node("hurt_p2"),
			win_1 = gui.get_node("p2_win_1"),
			win_2 = gui.get_node("p2_win_2")
		},
		round = gui.get_node("round"),
		fight = gui.get_node("fight"),
		winner = gui.get_node("winner")
	}
	
	play_music()
	start_round(self)
end

function on_input(self, action_id, action)
	if action_id == hash("debug") and action.pressed then
		msg.post("@system:", "toggle_physics_debug")
	end
end

local function end_round(self)
	if STATE.victor then
		STATE.score[STATE.victor] = STATE.score[STATE.victor] + 1
		gui.set_text(node.winner, STR[hash("main_winner")][SET.lang](FIGHTER[STATE.fighter[STATE.victor]].name))
		gui.set_enabled(node.winner, true)
		sound.play("/sound#"..FIGHTER[STATE.fighter[STATE.victor]].name, nil, function()
			sound.play("sound#wins", nil, function()
				gui.set_enabled(node.winner, false)
				timer.delay(SET.next_round_delay, false, start_round)
			end)
		end)
	else
		gui.set_text(node.winner, STR[hash("main_draw")][SET.lang])
		gui.set_enabled(node.winner, true)
		sound.play("sound#wins", nil, function()
			gui.set_enabled(node.winner, false)
			timer.delay(SET.next_round_delay, false, start_round)
		end)
	end	
end

function on_message(self, message_id, message, sender)
	if message_id == hash("damage_dealt") and STATE.health[message.player] > 0 then
		local new_health = math.max(STATE.health[message.player] - (message.amount * SET.damage_multiplier[message.player]), 0)
		STATE.health[message.player] = new_health
		gui.set_scale(node[message.player].health_bar, vmath.vector3(new_health / 100, 1, 1))
		gui.animate(node[message.player].hurt_bar, "scale.x", new_health / 100, gui.EASING_INOUTCUBIC, SET.hurt_bar_speed, SET.hurt_bar_delay)
		if not (new_health > 0) then
			msg.post(sender, hash("defeat"))
			gui.set_enabled(node[other_player[message.player]].win_1, STATE.score[other_player[message.player]] > -1)
			gui.set_enabled(node[other_player[message.player]].win_2, STATE.score[other_player[message.player]] > 0)
			timer.delay(SET.round_end_delay, false, end_round)

			
			if STATE.score[other_player[message.player]] > 1 then

			else

			end
		end
	end
end

function update(self, dt)
	STATE.frame = STATE.frame + 1
end

function final(self)

end