go.property("fighter", hash("stick"))
go.property("controls", 1)
go.property("facing", 1)
go.property("state", hash("intro"))

local INPUT = require("mod.input")
local FIGHTER = require("mod.fighters")
local STATE = require("mod.state")
local SET = require("mod.settings")

local movement_direction = {
	[-1] = {forward = hash("left"), backward = hash("right")},
	[1] = {forward = hash("right"), backward = hash("left")}
}

local function set_collision(self, collision, reset)
	if self.collision and (reset or not (collision == self.collision)) then
		msg.post("#"..self.collision, "disable")
	end
	if collision then
		msg.post("#"..collision, "enable")
	end
	self.collision = collision
end

local function reset_position(self, time)
	if time then
		set_collision(self, "stand")
		go.animate(".", "euler.z", go.PLAYBACK_ONCE_FORWARD, 0, go.EASING_LINEAR, time)
		go.animate(".", "position.y", go.PLAYBACK_ONCE_FORWARD, SET.base_y, go.EASING_LINEAR, time)
	else
		go.cancel_animations(".", "euler.z")
		go.cancel_animations(".", "position.y")
		go.set(".", "euler.z", 0)
		go.set(".", "position.y", SET.base_y)
	end
end

local function play_animation(self, anim, wait_until_finished, rate)
	if not (self.anim == anim) and not (anim == "stand" and self.anim == "wait") then
		self.anim = anim
		if not (anim == "duck_fast") then
			self.anim = anim
		else
			self.anim = "duck"
		end
		local complete_function
		if wait_until_finished then
			self.anim = "wait"
			complete_function = function() self.anim = "jump" end
		end
		sprite.play_flipbook("#sprite", anim, complete_function, {playback_rate = rate or 1})
	end
end

local function check_facing(self)
	if (go.get_world_position().x - go.get_world_position(self.enemy).x) * self.facing > 0 then
		if self.state == hash("ready") then play_animation(self, "turn", true) end
		self.facing = -self.facing
		sprite.set_hflip("#sprite", self.facing < 0)
	end
end

local function update_shadow()
	go.set_position(vmath.vector3(go.get_world_position().x, SET.shadow_y, -0.5), "shadow")
	sprite.set_constant("shadow#sprite", "tint", vmath.vector4(0, 0, 0, SET.shadow_alpha(go.get_world_position().y)))
	go.set_scale(vmath.vector3(SET.shadow_x_scale(go.get(".", "euler.z")), SET.shadow_y_scale, 1) / 2, "shadow")
end

function init(self)
	msg.post(".", hash("acquire_input_focus"))
	sprite.set_hflip("#sprite", self.facing < 0)
	for key, val in pairs(FIGHTER[self.fighter].hitbox_list) do
		msg.post("#"..val, "disable")
	end
	set_collision(self, "stand")
	self.actions = {}
	for key, val in pairs(INPUT[self.controls]) do
		self.actions[val] = false
	end
	self.blocked = false
	self.input_history = {}
	self.last_input = STATE.frame
	self.frame_actions = {}
	self.previous_position = go.get_world_position()
	update_shadow()
	play_animation(self, "stand")
end

local function add_action(self, action, frame)
	self.frame_actions[STATE.frame + frame] = self.frame_actions[STATE.frame + frame] or {}
	table.insert(self.frame_actions[STATE.frame + frame], action)
end

function update(self, dt)
	if self.last_input + SET.combo_input_delay < STATE.frame then
		self.input_history = {}
	end
	if self.frame_actions[STATE.frame] then
		for key, val in ipairs(self.frame_actions[STATE.frame]) do
			if val == hash("attack_recovery") then
				if self.state == hash("victor") then
					play_animation(self, "victory")
				else
					self.state = hash("ready")
				end
			elseif val == hash("attack_recovery_duck") then
				if self.state == hash("victor") then
					play_animation(self, "victory")
				else
					if self.actions[hash("duck")] then
						play_animation(self, "duck_fast")
						set_collision(self, "duck")
					end
					self.state = hash("ready")
				end
			elseif val == hash("damage_point") then
				local rot = vmath.quat_rotation_z(math.rad(self.move.hitbox_rotation or 0) * self.facing)
				local scale = vmath.vector3(1, 1, 1) * (self.move.hitbox_scale or 1)
				local hitbox = factory.create(self.move.hitbox, vmath.vector3(self.move.damage_pos.x * self.facing, self.move.damage_pos.y, 0), rot, nil, scale)
				msg.post(hitbox, hash("setup"), {myself = self.go, enemy = self.enemy, move = self.move, facing = self.facing})
				local pos = go.get_world_position()
				go.set_position(vmath.vector3(pos.x + (self.move.damage_pos.x * self.facing), pos.y + self.move.damage_pos.y, pos.z), hitbox)
				if self.move.hitbox == "#hitbox_jump" then
					self.hitbox = hitbox
				end
			elseif val == hash("victory_pose") then
				play_animation(self, "victory")
				set_collision(self, "stand")
				go.animate(".", "euler.z", go.PLAYBACK_ONCE_FORWARD, 0, go.EASING_LINEAR, 0.3)
				go.animate(".", "position.y", go.PLAYBACK_ONCE_FORWARD, SET.base_y, go.EASING_LINEAR, 0.3)
				self.frame_actions = {}
			elseif val == hash("pull_hook") then
				play_animation(self, "hook_pull")
				add_action(self, hash("attack_recovery"), 30)
			elseif val == hash("be_hooked") then
				play_animation(self, "pain_high")
				go.set_position(go.get_world_position(self.enemy) + vmath.vector3(90 * go.get(msg.url(nil, self.enemy, "fighter_control"), hash("facing")), 0, 0))
			elseif val == hash("remove_stun") then
				self.state = hash("ready")
			elseif val == hash("bike_ride") then
				self.state = hash("bike")
				set_collision(self, "duck")
				local hitbox = factory.create("#hitbox_bike", go.get_world_position())
				msg.post(hitbox, hash("setup"), {myself = self.go, enemy = self.enemy, move = self.move, facing = self.facing})
				go.set_parent(hitbox, ".", true)
				self.hitbox = hitbox
			end
		end
	end
	if self.state == hash("ready") then
		check_facing(self)
		if self.actions[hash("jump")] then
			reset_position(self)
			msg.post(".", hash("jump"))
		elseif self.actions[hash("duck")] then
			play_animation(self, "duck")
			set_collision(self, "duck")
		elseif self.actions[movement_direction[self.facing].forward] then
			if not self.blocked then
				local new_pos = go.get_world_position() + vmath.vector3(FIGHTER[self.fighter].speed_forwards * self.facing, 0, 0)
				new_pos.x = math.max(new_pos.x, SET.min_x)
				new_pos.x = math.min(new_pos.x, SET.max_x)
				go.set_position(new_pos)
			end
			play_animation(self, "walk")
			set_collision(self, "stand")
		elseif self.actions[movement_direction[self.facing].backward] then
			local new_pos = go.get_world_position() - vmath.vector3(FIGHTER[self.fighter].speed_backwards * self.facing, 0, 0)
			new_pos.x = math.max(new_pos.x, SET.min_x)
			new_pos.x = math.min(new_pos.x, SET.max_x)
			go.set_position(new_pos)
			play_animation(self, "walk_back")
			set_collision(self, "stand")
		else
			play_animation(self, "stand")
			set_collision(self, "stand")
		end
	elseif self.state == hash("ragdoll") and vmath.length_sqr(self.previous_position - go.get_world_position()) < SET.recovery_threshold then
		reset_position(self, SET.recovery_speed)
		play_animation(self, "stand")
		self.state = hash("ready")
	elseif self.state == hash("pain") then
		self.state = hash("ragdoll")
	elseif self.state == hash("bike") then
		local new_pos = go.get_world_position() + vmath.vector3(SET.bike_speed * self.facing, 0, 0)
		if new_pos.x < SET.min_x or new_pos.x > SET.max_x then
			self.state = hash("ready")
			set_collision(self, "stand")
			if self.hitbox then
				msg.post(self.hitbox, hash("die"))
				self.hitbox = nil
			end
		else
			go.set_position(new_pos)
		end
	end
	self.previous_position = go.get_world_position()
	self.blocked = false
	
	if math.abs(go.get_world_position().x - go.get_world_position(self.enemy).x) < SET.fighters_min_distance then
		local enemy_state = go.get(msg.url(nil, self.enemy, "fighter_control"), hash("state"))
		if not (enemy_state == hash("jump") or enemy_state == hash("attack") or enemy_state == hash("bike")) and
		not(self.state == hash("jump") or self.state == hash("attack") or self.state == hash("bike")) then
			go.set_position(go.get_world_position() + vmath.vector3(10, 0, 0) * -self.facing)
		end
	end
	update_shadow()
end

function on_message(self, message_id, message, sender)
	if message_id == hash("collision_response") then
		if message.other_group == hash("fighter") then
			self.blocked = true
		end
	elseif message_id == hash("contact_point_response") then
		if message.other_group == hash("ground") and (self.state == hash("jump") or self.state == hash("attack")) then
			self.state = hash("ready")
			set_collision(self, "stand")
			play_animation(self, "land", true)
			reset_position(self, 0.05)
			if self.hitbox then
				msg.post(self.hitbox, hash("die"))
				self.hitbox = nil
			end
		end
	elseif message_id == hash("attack_landed") then
		set_collision(self, "stand")
		if message.move.anim == "hook" then
			self.state = hash("stun")
			play_animation(self, "pain_low")
			go.set_position(go.get_world_position(self.enemy) + vmath.vector3(400 * go.get(msg.url(nil, self.enemy, "fighter_control"), hash("facing")), 100, 0))
			msg.post(self.enemy, hash("hook_landed"))
			self.frame_actions = {}
			add_action(self, hash("be_hooked"), SET.hook_delay)
			add_action(self, hash("remove_stun"), SET.hook_delay + SET.hook_stun)
			msg.post("/main#gui", hash("damage_dealt"), {player = self.controls, amount = message.move.damage})
		else
			if message.move.anim == "bike" then
				msg.post(self.enemy, hash("bike_landed"))
			end
			set_collision(self, "ragdoll")
			msg.post("#ragdoll", "apply_force", {force = vmath.vector3(message.move.force.x * -self.facing, message.move.force.y, 0), position = message.pos})
			if not (self.state == hash("dead")) then
				self.state = hash("pain")
				if message.pos.y - go.get_world_position().y > SET.high_pain_threshold then
					play_animation(self, "pain_high")
				else
					play_animation(self, "pain_low")
				end
				self.frame_actions = {}
				msg.post("/main#gui", hash("damage_dealt"), {player = self.controls, amount = message.move.damage})
			end
			if self.hitbox then
				msg.post(self.hitbox, hash("die"))
				self.hitbox = nil
			end
		end
	elseif message_id == hash("hook_landed") then
		self.frame_actions = {}
		self.state = hash("hooking")
		add_action(self, hash("pull_hook"), SET.hook_delay)
	elseif message_id == hash("bike_landed") then
		set_collision(self)
		self.hitbox = nil
	elseif message_id == hash("attack_pushback") then
		local direction = (self.previous_position.x - go.get_world_position().x) * -self.facing
		local magic_number = SET.jump_force.x / 14400
		local multiplier = (direction + magic_number) / magic_number
		msg.post("#"..self.collision, "apply_force", {force = vmath.vector3(message.move.force.x * -self.facing * multiplier, 0, 0), position = message.pos})
		if self.hitbox then
			msg.post(self.hitbox, hash("die"))
			self.hitbox = nil
		end
	elseif message_id == hash("jump") then
		local force_x, force_y, anim = SET.jump_force.x, SET.jump_force.y, "jump"
		if self.actions[movement_direction[self.facing].forward] then
			force_x = force_x * self.facing
			anim = "jump_front"
			set_collision(self, "jump_rotate")
		elseif self.actions[movement_direction[self.facing].backward] then
			force_x = force_x * -self.facing
			anim = "jump_back"
			set_collision(self, "jump_rotate")
		else
			force_x = 0
			set_collision(self, "jump_up")
		end
		msg.post("#"..self.collision, "apply_force", {force = vmath.vector3(force_x, force_y, 0), position = go.get_world_position()})
		self.state = hash("jump")
		play_animation(self, anim)
	elseif message_id == hash("setup_gos") then
		self.go = message.myself
		self.enemy = message.enemy
	elseif message_id == hash("start") then
		self.state = hash("ready")
	elseif message_id == hash("defeat") then
		self.state = hash("dead")
		self.frame_actions = {}
		msg.post(self.enemy, hash("victory"))
	elseif message_id == hash("victory") then
		if not (self.state == hash("dead")) then
			self.state = hash("victor")
			add_action(self, hash("victory_pose"), 60)
			STATE.victor = self.controls
		end
	elseif message_id == hash("delete_self") then
		go.delete(".", true)
	end
end

local function execute_move(self, move)
	check_facing(self)
	self.state = hash("attack")
	self.move = move
	play_animation(self, move.anim, false, move.playback_rate)
	if move.anim == "uppercut" then	-- WIP
		set_collision(self, "stand")
	elseif move.anim == "bike" then
		add_action(self, hash("bike_ride"), move.bike_ready)
	end
	if move.damage_point then
		add_action(self, hash("damage_point"), move.damage_point)
	end
	if move.recovery then
		add_action(self, move.recovery_type, move.recovery)
	end
end

function on_input(self, action_id, action)
	local key_press = INPUT[self.controls][action_id]
	if key_press then
		self.actions[key_press] = action.pressed or not action.released
		if action.pressed then
			local input = key_press
			if input == movement_direction[self.facing].forward then
				input = hash("forward")
			elseif input == movement_direction[self.facing].backward then
				input = hash("backward")
			end
			table.insert(self.input_history, 1, input)
			if #self.input_history > SET.input_history_length then
				table.remove(self.input_history)
			end
			self.last_input = STATE.frame
		end
	end
	if (key_press == hash("punch") or key_press == hash("kick")) and (self.state == hash("ready") or self.state == hash("jump")) and action.pressed then
		for _, move in ipairs(FIGHTER[self.fighter].moves[key_press]) do
			if self.state == move.state then
				local correct_input = true
				for __, val in ipairs(move.keys_held) do
					if not (type(val) == "string" and self.actions[movement_direction[self.facing][val]]) and not (type(val) == "userdata" and self.actions[val]) then
						correct_input = false
					end
				end
				for key, val in ipairs(move.keys_sequence) do
					if not (self.input_history[key] == val) then
						correct_input = false
					end
				end
				if correct_input then
					execute_move(self, move)
					break
				end
			end
		end
	end
end

function final(self)
	go.delete("shadow")
	go.delete()
end