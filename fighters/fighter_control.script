go.property("fighter", hash("stick"))
go.property("controls", 1)
go.property("facing", 1)

go.property("gfx_stick", resource.atlas("/fighters/stick.atlas"))
go.property("gfx_red", resource.atlas("/fighters/red.atlas"))
go.property("gfx_vojta_beta", resource.atlas("/fighters/vojta_beta.atlas"))

local INPUT = require("mod.input")
local FIGHTER = require("mod.fighters")
local STATE = require("mod.state")
local SET = require("mod.settings")

local movement_direction = {
	[-1] = {forward = hash("left"), backward = hash("right")},
	[1] = {forward = hash("right"), backward = hash("left")}
}

function init(self)
	msg.post(".", hash("acquire_input_focus"))
	local gfx = {[hash("stick")] = self.gfx_stick, [hash("red")] = self.gfx_red, [hash("vojta_beta")] = self.gfx_vojta_beta}
	go.set("#sprite", "image", gfx[self.fighter])
	if self.facing < 0 then sprite.set_hflip("#sprite", true) end
	msg.post("#co_physics", "disable")
	msg.post("#co_duck", "disable")
	self.actions = {}
	for key, val in pairs(INPUT[self.controls]) do
		self.actions[val] = false
	end
	self.blocked = false
	self.state = hash("ready")
	self.frame_actions = {}
	self.previous_position = go.get_position()
	self.anim = hash("stand")
	sprite.play_flipbook("#sprite", "stand")
end

local function add_action(self, action, frame)
	self.frame_actions[STATE.frame + frame] = self.frame_actions[STATE.frame + frame] or {}
	table.insert(self.frame_actions[STATE.frame + frame], action)
end

function update(self, dt)
	if self.frame_actions[STATE.frame] then
		for key, val in ipairs(self.frame_actions[STATE.frame]) do
			if val == hash("attack_recovery") then
				self.state = hash("ready")
				self.anim = hash("ready")
			elseif val == hash("damage_point") then
				local hitbox = factory.create(self.move.hitbox, vmath.vector3(self.move.damage_pos.x * self.facing, self.move.damage_pos.y, 0), nil, nil, 1)
				msg.post(hitbox, hash("setup"), {myself = self.go, enemy = self.enemy, move = self.move, facing = self.facing})
				local pos = go.get_position()
				go.set_position(vmath.vector3(pos.x + (self.move.damage_pos.x * self.facing), pos.y + self.move.damage_pos.y, pos.z), hitbox)
			end
		end
	end
	if self.state == hash("ready") then
		if self.actions[hash("duck")] then
			if self.anim ~= hash("duck") then
				sprite.play_flipbook("#sprite", "duck")
				self.anim = hash("duck")
				msg.post("#co", "disable")
				msg.post("#co_duck", "enable")
			end
		elseif self.actions[movement_direction[self.facing].forward] then
			if not self.blocked then
				go.set_position(go.get_position() + vmath.vector3(FIGHTER[self.fighter].speed_forwards * self.facing, 0, 0))
			end
			if self.anim ~= hash("walk") then
				sprite.play_flipbook("#sprite", "walk")
				self.anim = hash("walk")
				msg.post("#co", "enable")
				msg.post("#co_duck", "disable")
			end
		elseif self.actions[movement_direction[self.facing].backward] then
			go.set_position(go.get_position() - vmath.vector3(FIGHTER[self.fighter].speed_backwards * self.facing, 0, 0))
			if self.anim ~= hash("walk") then
				sprite.play_flipbook("#sprite", "walk")
				self.anim = hash("walk")
				msg.post("#co", "enable")
				msg.post("#co_duck", "disable")
			end
		else
			if self.anim ~= hash("stand") then
				sprite.play_flipbook("#sprite", "stand")
				self.anim = hash("stand")
				msg.post("#co", "enable")
				msg.post("#co_duck", "disable")
			end
		end
	end
	self.blocked = false
	if self.state == hash("ragdoll") and vmath.length_sqr(self.previous_position - go.get_position()) < SET.recovery_threshold then
		msg.post("#co_physics", "disable")
		msg.post("#co", "enable")
		go.animate(".", "euler.z", go.PLAYBACK_ONCE_FORWARD, 0, go.EASING_LINEAR, 0.3)
		go.animate(".", "position.y", go.PLAYBACK_ONCE_FORWARD, SET.base_y, go.EASING_LINEAR, 0.3)
		sprite.play_flipbook("#sprite", "stand")
		self.state = hash("ready")
	elseif self.state == hash("pain") then
		self.state = hash("ragdoll")
	end
	self.previous_position = go.get_position()
end

function on_message(self, message_id, message, sender)
	if message_id == hash("collision_response") then
		if message.other_group == hash("fighter") then
			self.blocked = true
		end
	elseif message_id == hash("attack_landed") then
		msg.post("#co", "disable")
		msg.post("#co_duck", "disable")
		msg.post("#co_physics", "enable")
		msg.post("#co_physics", "apply_force", {force = vmath.vector3(message.move.force.x * -self.facing, message.move.force.y, 0), position = message.pos})
		self.state = hash("pain")
		sprite.play_flipbook("#sprite", "pain")
		self.frame_actions = {}
	elseif message_id == hash("setup_gos") then
		self.go = message.myself
		self.enemy = message.enemy
	end
end

local function execute_move(self, move)
	self.state = hash("attack")
	self.move = move
	self.anim = hash("attack")
	sprite.play_flipbook("#sprite", move.anim)
	add_action(self, hash("damage_point"), move.damage_point)
	add_action(self, hash("attack_recovery"), move.recovery)
end

function on_input(self, action_id, action)
	if INPUT[self.controls][action_id] then
		self.actions[INPUT[self.controls][action_id]] = action.pressed or not action.released
	end
	
	if INPUT[self.controls][action_id] == hash("punch") and self.state == hash("ready") and action.pressed then
		for _, move in ipairs(FIGHTER[self.fighter].moves[hash("punch")]) do
			local correct_input = true
			for __, val in ipairs(move.keys_held) do
				if not (type(val) == "string" and self.actions[movement_direction[self.facing][val]]) and not (type(val) == "userdata" and self.actions[val]) then
					correct_input = false
				end
			end
			if correct_input then
				execute_move(self, move)
				break
			end
		end
	end
end