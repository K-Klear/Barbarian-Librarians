go.property("fighter", hash("stick"))
go.property("controls", 1)
go.property("facing", 1)
go.property("state", hash("intro"))

go.property("gfx_stick", resource.atlas("/fighters/stick.atlas"))
go.property("gfx_bohous", resource.atlas("/fighters/bohous.atlas"))
go.property("gfx_vojta_beta", resource.atlas("/fighters/vojta_beta.atlas"))

local INPUT = require("mod.input")
local FIGHTER = require("mod.fighters")
local STATE = require("mod.state")
local SET = require("mod.settings")

local movement_direction = {
	[-1] = {forward = hash("left"), backward = hash("right")},
	[1] = {forward = hash("right"), backward = hash("left")}
}

local function set_collision(collision)
	local collisions = {
		[hash("stand")] = {co_ragdoll = "disable", co_duck = "disable", co = "enable", co_jump_physics = "disable"},
		[hash("duck")] = {co_ragdoll = "disable", co_duck = "enable", co = "disable", co_jump_physics = "disable"},
		[hash("ragdoll")] = {co_ragdoll = "enable", co_duck = "disable", co = "disable", co_jump_physics = "disable"},
		[hash("jump")] = {co_ragdoll = "disable", co_duck = "disable", co = "disable", co_jump_physics = "enable"},
	}
	for key, val in pairs(collisions[collision]) do
		msg.post("#"..key, val)
	end
end

local function reset_position(time)
	if time then
		set_collision(hash("stand"))
		go.animate(".", "euler.z", go.PLAYBACK_ONCE_FORWARD, 0, go.EASING_LINEAR, time)
		go.animate(".", "position.y", go.PLAYBACK_ONCE_FORWARD, SET.base_y, go.EASING_LINEAR, time)
	else
		go.cancel_animations(".", "euler.z")
		go.cancel_animations(".", "position.y")
		go.set(".", "euler.z", 0)
		go.set(".", "position.y", SET.base_y)
	end
end

local function play_animation(self, anim, wait_until_finished, rate)
	if not (self.anim == anim) and not (anim == "stand" and self.anim == "wait") then
		self.anim = anim
		if not (anim == "duck_fast") then
			self.anim = anim
		else
			self.anim = "duck"
		end
		local complete_function
		if wait_until_finished then
			self.anim = "wait"
			complete_function = function() self.anim = "jump" end
		end
		sprite.play_flipbook("#sprite", anim, complete_function, {playback_rate = rate or 1})
	end
end


local function check_facing(self)
	if (go.get_position().x - go.get_position(self.enemy).x) * self.facing > 0 then
		if self.state == hash("ready") then play_animation(self, "turn", true) end
		self.facing = -self.facing
		sprite.set_hflip("#sprite", self.facing < 0)
	end
end

function init(self)
	msg.post(".", hash("acquire_input_focus"))
	local gfx = {
		[hash("vojta_beta")] = self.gfx_vojta_beta,
		[hash("bohous")] = self.gfx_bohous
	}
	go.set("#sprite", "image", gfx[self.fighter])
	sprite.set_hflip("#sprite", self.facing < 0)
	set_collision(hash("stand"))
	self.actions = {}
	for key, val in pairs(INPUT[self.controls]) do
		self.actions[val] = false
	end
	self.blocked = false
	self.state = hash("intro")
	self.input_history = {}
	self.last_input = STATE.frame
	self.frame_actions = {}
	self.previous_position = go.get_position()
	play_animation(self, "stand")
end

local function add_action(self, action, frame)
	self.frame_actions[STATE.frame + frame] = self.frame_actions[STATE.frame + frame] or {}
	table.insert(self.frame_actions[STATE.frame + frame], action)
end

function update(self, dt)
	if self.last_input + SET.combo_input_delay < STATE.frame then
		self.input_history = {}
	end
	if self.frame_actions[STATE.frame] then
		for key, val in ipairs(self.frame_actions[STATE.frame]) do
			if val == hash("attack_recovery") then
				if self.state == hash("victor") then
					play_animation(self, "victory")
				else
					self.state = hash("ready")
				end
			elseif val == hash("attack_recovery_duck") then
				if self.state == hash("victor") then
					play_animation(self, "victory")
				else
					if self.actions[hash("duck")] then
						play_animation(self, "duck_fast")
						set_collision(hash("duck"))
					end
					self.state = hash("ready")
				end
			elseif val == hash("damage_point") then
				local hitbox = factory.create(self.move.hitbox, vmath.vector3(self.move.damage_pos.x * self.facing, self.move.damage_pos.y, 0), nil, nil, 1)
				msg.post(hitbox, hash("setup"), {myself = self.go, enemy = self.enemy, move = self.move, facing = self.facing})
				local pos = go.get_position()
				go.set_position(vmath.vector3(pos.x + (self.move.damage_pos.x * self.facing), pos.y + self.move.damage_pos.y, pos.z), hitbox)
				if self.move.hitbox == "#hitbox_jump" then
					self.hitbox = hitbox
				end
			elseif val == hash("victory_pose") then
				play_animation(self, "victory")
				set_collision(hash("stand"))
				go.animate(".", "euler.z", go.PLAYBACK_ONCE_FORWARD, 0, go.EASING_LINEAR, 0.3)
				go.animate(".", "position.y", go.PLAYBACK_ONCE_FORWARD, SET.base_y, go.EASING_LINEAR, 0.3)
				self.frame_actions = {}
			end
		end
	end
	if self.state == hash("ready") then
		check_facing(self)
		if self.actions[hash("jump")] then
			reset_position()
			msg.post(".", hash("jump"))
		elseif self.actions[hash("duck")] then
			play_animation(self, "duck")
			set_collision(hash("duck"))
		elseif self.actions[movement_direction[self.facing].forward] then
			if not self.blocked then
				local new_pos = go.get_position() + vmath.vector3(FIGHTER[self.fighter].speed_forwards * self.facing, 0, 0)
				new_pos.x = math.max(new_pos.x, SET.min_x)
				new_pos.x = math.min(new_pos.x, SET.max_x)
				go.set_position(new_pos)
			end
			play_animation(self, "walk")
			set_collision(hash("stand"))
		elseif self.actions[movement_direction[self.facing].backward] then
			local new_pos = go.get_position() - vmath.vector3(FIGHTER[self.fighter].speed_backwards * self.facing, 0, 0)
			new_pos.x = math.max(new_pos.x, SET.min_x)
			new_pos.x = math.min(new_pos.x, SET.max_x)
			go.set_position(new_pos)
			play_animation(self, "walk_back")
			set_collision(hash("stand"))
		else
			play_animation(self, "stand")
			set_collision(hash("stand"))
		end
	elseif self.state == hash("ragdoll") and vmath.length_sqr(self.previous_position - go.get_position()) < SET.recovery_threshold then
		reset_position(SET.recovery_speed)
		play_animation(self, "stand")
		self.state = hash("ready")
	elseif self.state == hash("pain") then
		self.state = hash("ragdoll")
	end
	self.previous_position = go.get_position()
	self.blocked = false
	
	if math.abs(go.get_position().x - go.get_position(self.enemy).x) < SET.fighters_min_distance then
		local enemy_state = go.get(msg.url(nil, self.enemy, "fighter_control"), hash("state"))
		if not (enemy_state == hash("jump") or enemy_state == hash("attack")) then
			go.set_position(go.get_position() + vmath.vector3(10, 0, 0) * -self.facing)
		end
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("collision_response") then
		if message.other_group == hash("fighter") then
			self.blocked = true
		end
	elseif message_id == hash("contact_point_response") then
		if message.other_group == hash("ground") and (self.state == hash("jump") or self.state == hash("attack")) then
			self.state = hash("ready")
			set_collision(hash("stand"))
			play_animation(self, "land", true)
			reset_position(0.05)
			if self.hitbox then
				msg.post(self.hitbox, hash("die"))
				self.hitbox = nil
			end
		end
	elseif message_id == hash("attack_landed") then
		set_collision(hash("stand"))
		set_collision(hash("ragdoll"))

		msg.post("#co_ragdoll", "apply_force", {force = vmath.vector3(message.move.force.x * -self.facing, message.move.force.y, 0), position = message.pos})
		if not (self.state == hash("dead")) then
			self.state = hash("pain")
			if message.pos.y - go.get_world_position().y > SET.high_pain_threshold then
				play_animation(self, "pain_high")
			else
				play_animation(self, "pain_low")
			end
			self.frame_actions = {}
			msg.post("/main#gui", hash("damage_dealt"), {player = self.controls, amount = message.move.damage})
		end
		if self.hitbox then
			msg.post(self.hitbox, hash("die"))
			self.hitbox = nil
		end
	elseif message_id == hash("attack_pushback") then
		local direction = (self.previous_position.x - go.get_position().x) * -self.facing
		local magic_number = SET.jump_force.x / 14400
		local multiplier = (direction + magic_number) / magic_number
		msg.post("#co_jump_physics", "apply_force", {force = vmath.vector3(message.move.force.x * -self.facing * multiplier, 0, 0), position = message.pos})
		if self.hitbox then
			msg.post(self.hitbox, hash("die"))
			self.hitbox = nil
		end
	elseif message_id == hash("jump") then
		set_collision(hash("jump"))
		local force_x, force_y, anim = SET.jump_force.x, SET.jump_force.y, "jump"
		if self.actions[movement_direction[self.facing].forward] then
			force_x = force_x * self.facing
			anim = "jump_front"
		elseif self.actions[movement_direction[self.facing].backward] then
			force_x = force_x * -self.facing
			anim = "jump_back"
		else
			force_x = 0
		end
		msg.post("#co_jump_physics", "apply_force", {force = vmath.vector3(force_x, force_y, 0), position = go.get_position()})
		self.state = hash("jump")
		play_animation(self, anim)
	elseif message_id == hash("setup_gos") then
		self.go = message.myself
		self.enemy = message.enemy
	elseif message_id == hash("start") then
		self.state = hash("ready")
	elseif message_id == hash("defeat") then
		self.state = hash("dead")
		self.frame_actions = {}
		msg.post(self.enemy, hash("victory"))
	elseif message_id == hash("victory") then
		if not (self.state == hash("dead")) then
			self.state = hash("victor")
			add_action(self, hash("victory_pose"), 60)
			STATE.victor = self.controls
		end
	elseif message_id == hash("delete_self") then
		go.delete(".", true)
	end
end

local function execute_move(self, move)
	check_facing(self)
	self.state = hash("attack")
	self.move = move
	play_animation(self, move.anim, false, move.playback_rate)
	if move.anim == "uppercut" then	-- WIP
		set_collision(hash("stand"))
	end
	add_action(self, hash("damage_point"), move.damage_point)
	if move.recovery then
		add_action(self, move.recovery_type, move.recovery)
	end
end

function on_input(self, action_id, action)
	local key_press = INPUT[self.controls][action_id]
	
	if key_press then
		self.actions[key_press] = action.pressed or not action.released
		if action.pressed then
			local input = key_press
			if input == movement_direction[self.facing].forward then
				input = hash("forward")
			elseif input == movement_direction[self.facing].backward then
				input = hash("backward")
			end
			table.insert(self.input_history, 1, input)
			if #self.input_history > SET.input_history_length then
				table.remove(self.input_history)
			end
			self.last_input = STATE.frame
		end
	end
	--[[
	if key_press == hash("jump") and self.state == hash("ready") and action.pressed then
		reset_position()
		msg.post(".", hash("jump"))
	end
	--]]
	if (key_press == hash("punch") or key_press == hash("kick")) and (self.state == hash("ready") or self.state == hash("jump")) and action.pressed then
		for _, move in ipairs(FIGHTER[self.fighter].moves[key_press]) do
			if self.state == move.state then
				local correct_input = true
				for __, val in ipairs(move.keys_held) do
					if not (type(val) == "string" and self.actions[movement_direction[self.facing][val]]) and not (type(val) == "userdata" and self.actions[val]) then
						correct_input = false
					end
				end
				for key, val in ipairs(move.keys_sequence) do
					if not (self.input_history[key] == val) then
						correct_input = false
					end
				end
				if correct_input then
					execute_move(self, move)
					break
				end
			end
		end
	end
end

function final(self)
	go.delete()
end