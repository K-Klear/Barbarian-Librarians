go.property("fighter", hash("stick"))
go.property("controls", 1)
go.property("facing", 1)

go.property("gfx_stick", resource.atlas("/fighters/stick.atlas"))
go.property("gfx_red", resource.atlas("/fighters/red.atlas"))
go.property("gfx_vojta_beta", resource.atlas("/fighters/vojta_beta.atlas"))

local INPUT = require("mod.input")
local FIGHTER = require("mod.fighters")
local STATE = require("mod.state")
local SET = require("mod.settings")

local movement_direction = {
	[-1] = {forward = hash("left"), backward = hash("right")},
	[1] = {forward = hash("right"), backward = hash("left")}
}

local function set_collision(collision)
	local collisions = {
		[hash("stand")] = {co_ragdoll = "disable", co_duck = "disable", co = "enable", co_jump_physics = "disable", co_jump = "disable"},
		[hash("duck")] = {co_ragdoll = "disable", co_duck = "enable", co = "disable", co_jump_physics = "disable", co_jump = "disable"},
		[hash("ragdoll")] = {co_ragdoll = "enable", co_duck = "disable", co = "disable", co_jump_physics = "disable", co_jump = "disable"},
		[hash("jump")] = {co_ragdoll = "disable", co_duck = "disable", co = "disable", co_jump_physics = "enable", co_jump = "enable"},
	}
	for key, val in pairs(collisions[collision]) do
		msg.post("#"..key, val)
	end
end

local function reset_position(time)
	set_collision(hash("stand"))
	go.animate(".", "euler.z", go.PLAYBACK_ONCE_FORWARD, 0, go.EASING_LINEAR, time)
	go.animate(".", "position.y", go.PLAYBACK_ONCE_FORWARD, SET.base_y, go.EASING_LINEAR, time)
end

local function play_animation(self, anim)
	if not (self.anim == anim) then
		self.anim = anim
		sprite.play_flipbook("#sprite", anim)
	end
end

function init(self)
	msg.post(".", hash("acquire_input_focus"))
	local gfx = {[hash("vojta_beta")] = self.gfx_vojta_beta}
	go.set("#sprite", "image", gfx[self.fighter])
	sprite.set_hflip("#sprite", self.facing < 0)
	set_collision(hash("stand"))
	self.actions = {}
	for key, val in pairs(INPUT[self.controls]) do
		self.actions[val] = false
	end
	self.blocked = false
	self.state = hash("intro")
	self.input_history = {}
	self.last_input = STATE.frame
	self.frame_actions = {}
	self.previous_position = go.get_position()
	play_animation(self, "stand")
end

local function add_action(self, action, frame)
	self.frame_actions[STATE.frame + frame] = self.frame_actions[STATE.frame + frame] or {}
	table.insert(self.frame_actions[STATE.frame + frame], action)
end

function update(self, dt)
	if self.last_input + SET.combo_input_delay < STATE.frame then
		self.input_history = {}
	end
	if self.frame_actions[STATE.frame] then
		for key, val in ipairs(self.frame_actions[STATE.frame]) do
			if val == hash("attack_recovery") then
				if self.state == hash("victor") then
					play_animation(self, "victory")
				else
					self.state = hash("ready")
					play_animation(self, "stand")
				end
			elseif val == hash("damage_point") then
				local hitbox = factory.create(self.move.hitbox, vmath.vector3(self.move.damage_pos.x * self.facing, self.move.damage_pos.y, 0), nil, nil, 1)
				msg.post(hitbox, hash("setup"), {myself = self.go, enemy = self.enemy, move = self.move, facing = self.facing})
				local pos = go.get_position()
				go.set_position(vmath.vector3(pos.x + (self.move.damage_pos.x * self.facing), pos.y + self.move.damage_pos.y, pos.z), hitbox)
			elseif val == hash("victory_pose") then
				play_animation(self, "victory")
				set_collision(hash("stand"))
				go.animate(".", "euler.z", go.PLAYBACK_ONCE_FORWARD, 0, go.EASING_LINEAR, 0.3)
				go.animate(".", "position.y", go.PLAYBACK_ONCE_FORWARD, SET.base_y, go.EASING_LINEAR, 0.3)
				self.frame_actions = {}
			end
		end
	end
	if self.state == hash("ready") then
		if self.actions[hash("duck")] then
			play_animation(self, "duck")
			set_collision(hash("duck"))
		elseif self.actions[movement_direction[self.facing].forward] then
			if not self.blocked then
				local new_pos = go.get_position() + vmath.vector3(FIGHTER[self.fighter].speed_forwards * self.facing, 0, 0)
				new_pos.x = math.max(new_pos.x, SET.min_x)
				new_pos.x = math.min(new_pos.x, SET.max_x)
				go.set_position(new_pos)
			end
			play_animation(self, "walk")
			set_collision(hash("stand"))
		elseif self.actions[movement_direction[self.facing].backward] then
			local new_pos = go.get_position() - vmath.vector3(FIGHTER[self.fighter].speed_backwards * self.facing, 0, 0)
			new_pos.x = math.max(new_pos.x, SET.min_x)
			new_pos.x = math.min(new_pos.x, SET.max_x)
			go.set_position(new_pos)
			play_animation(self, "walk")
			set_collision(hash("stand"))
		else
			play_animation(self, "stand")
			set_collision(hash("stand"))
		end
	end
	self.blocked = false
	if self.state == hash("ragdoll") and vmath.length_sqr(self.previous_position - go.get_position()) < SET.recovery_threshold then
		reset_position(SET.recovery_speed)
		play_animation(self, "stand")
		self.state = hash("ready")
	elseif self.state == hash("pain") then
		self.state = hash("ragdoll")
	end
	self.previous_position = go.get_position()
	if (go.get_position().x - go.get_position(self.enemy).x) * self.facing > 0 then
		self.facing = -self.facing
		sprite.set_hflip("#sprite", self.facing < 0)
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("collision_response") then
		if message.other_group == hash("fighter") then
			self.blocked = true
		end
	elseif message_id == hash("contact_point_response") then
		if message.other_group == hash("ground") and (self.state == hash("jump") or self.state == hash("attack")) then
			self.state = hash("ready")
			set_collision(hash("stand"))
			play_animation(self, "stand")
			reset_position(0.05)
		end
		--[[
		if true then
			if self.state == hash("jump") then
				play_animation(self, "pain")
				self.state = hash("drop")
				set_collision(hash("stand"))
				set_collision(hash("ragdoll"))
				timer.delay(0.3, false, function() self.state = hash("ragdoll") end)
				pprint(message)
				-- solve this using "contact_point_response". See docs
			end
		elseif message.other_group == hash("ground") and self.state == hash("jump") then
			self.state = hash("ready")
			set_collision(hash("stand"))
			play_animation(self, "stand")
			reset_position(0.05)
		end
		--]]
	elseif message_id == hash("attack_landed") then
		set_collision(hash("stand"))
		set_collision(hash("ragdoll"))
		msg.post("#co_ragdoll", "apply_force", {force = vmath.vector3(message.move.force.x * -self.facing, message.move.force.y, 0), position = message.pos})
		if not (self.state == hash("dead")) then
			self.state = hash("pain")
			play_animation(self, "pain")
			self.frame_actions = {}
			msg.post("/main#gui", hash("damage_dealt"), {player = self.controls, amount = message.move.damage})
		end
	elseif message_id == hash("setup_gos") then
		self.go = message.myself
		self.enemy = message.enemy
	elseif message_id == hash("start") then
		self.state = hash("ready")
	elseif message_id == hash("defeat") then
		self.state = hash("dead")
		self.frame_actions = {}
		msg.post(self.enemy, hash("victory"))
	elseif message_id == hash("victory") then
		if not (self.state == hash("dead")) then
			self.state = hash("victor")
			add_action(self, hash("victory_pose"), 60)
			STATE.victor = self.controls
		end
	elseif message_id == hash("delete_self") then
		go.delete(".", true)
	end
end

local function execute_move(self, move)
	self.state = hash("attack")
	self.move = move
	play_animation(self, move.anim)
	if move.anim == "uppercut" then	-- WIP
		set_collision(hash("stand"))
	end
	add_action(self, hash("damage_point"), move.damage_point)
	if move.recovery then
		add_action(self, hash("attack_recovery"), move.recovery)
	end
end

function on_input(self, action_id, action)
	if INPUT[self.controls][action_id] then
		self.actions[INPUT[self.controls][action_id]] = action.pressed or not action.released
		if action.pressed then
			local input = INPUT[self.controls][action_id]
			if input == movement_direction[self.facing].forward then
				input = hash("forward")
			elseif input == movement_direction[self.facing].backward then
				input = hash("backward")
			end
			table.insert(self.input_history, 1, input)
			if #self.input_history > SET.input_history_length then
				table.remove(self.input_history)
			end
			self.last_input = STATE.frame
		end
	end
	if INPUT[self.controls][action_id] == hash("jump") and self.state == hash("ready") and action.pressed then
		set_collision(hash("jump"))
		local force_y, force_x = 150000, 0
		if self.actions[movement_direction[self.facing].forward] then
			force_x = (force_y / 2) * self.facing
		elseif self.actions[movement_direction[self.facing].backward] then
			force_x = (force_y / 2) * -self.facing
		end
		msg.post("#co_jump_physics", "apply_force", {force = vmath.vector3(force_x, force_y, 0), position = go.get_position()})
		self.state = hash("jump")
		play_animation(self, "jump")
	end
	if INPUT[self.controls][action_id] == hash("punch") and (self.state == hash("ready") or self.state == hash("jump")) and action.pressed then
		for _, move in ipairs(FIGHTER[self.fighter].moves[hash("punch")]) do
			if self.state == move.state then
				local correct_input = true
				for __, val in ipairs(move.keys_held) do
					if not (type(val) == "string" and self.actions[movement_direction[self.facing][val]]) and not (type(val) == "userdata" and self.actions[val]) then
						correct_input = false
					end
				end
				for key, val in ipairs(move.keys_sequence) do
					if not (self.input_history[key] == val) then
						correct_input = false
					end
				end
				if correct_input then
					execute_move(self, move)
					break
				end
			end
		end
	end
end

function final(self)
	go.delete()
end